# FastFlowTransform pipeline and project lifecycle targets


.PHONY: seed run dag demo demo-open test clean

FFT := FF_ENGINE=duckdb FF_DUCKDB_PATH="$(FF_DB)" fft

init:
	$(UV) fft init examples/materializations_demo  

seed:
	$(FFT) seed "$(FF_PROJECT)" --env dev

# Run/DAG/Test reuse the same duckdb path (FF_ENV can switch engine)
run:
	$(FFT) run "$(FF_PROJECT)" --env "$(FF_ENV)" --jobs=1

run_parallel:
	# Two independent staging nodes ("users", "orders") run in parallel
	FF_ENGINE=duckdb FF_DUCKDB_PATH="$(DB)" fft run "$(PROJECT)" --env dev --jobs 4

run-parallel:
	$(FFT) run "$(FF_PROJECT)" --env "$(FF_ENV)" --jobs=4 --keep-going

dag:
	$(FFT) dag "$(FF_PROJECT)" --env "$(FF_ENV)" --html

# Opens the generated DAG HTML on macOS/Linux; Windows users open it manually.
demo-open:
	@if [ -f "$(FF_PROJECT)/site/dag/index.html" ]; then \
		$(OPENER) "$(FF_PROJECT)/site/dag/index.html" 2>/dev/null || echo "Oopen at: $(FF_PROJECT)/site/dag/index.html"; \
	else \
		echo "No HTML found: $(FF_PROJECT)/site/dag/index.html"; \
	fi

test:
	$(FFT) test "$(FF_PROJECT)" --env "$(FF_ENV)" --select batch

# End-to-end showcase: Seed → Run → DAG → Open → Tests
demo: seed run dag demo-open test
	@echo "\n✓ Demo done."

clean:
	rm -rf .local "$(FF_PROJECT)/docs" dist build *.egg-info

# --- Cache demos (v0.3) ---

cache_rw_first:
	# first run writes cache and meta
	FF_ENGINE=duckdb FF_DUCKDB_PATH="$(DB)" fft run "$(PROJECT)" --env dev --cache=rw

cache_rw_second:
	# second run: should be a no-op (skips) if nothing changed
	FF_ENGINE=duckdb FF_DUCKDB_PATH="$(DB)" fft run "$(PROJECT)" --env dev --cache=rw

cache_invalidate_env:
	# changing an FF_* env var invalidates fingerprints
	FF_ENGINE=duckdb FF_DUCKDB_PATH="$(DB)" FF_DEMO_TOGGLE=1 fft run "$(PROJECT)" --env dev --cache=rw

rebuild_users:
	# force rebuild of a single model regardless of cache
	FF_ENGINE=duckdb FF_DUCKDB_PATH="$(DB)" fft run "$(PROJECT)" --env dev --cache=rw --rebuild users.ff
	
